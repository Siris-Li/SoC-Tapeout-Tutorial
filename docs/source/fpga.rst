FPGA Implementation
=========

.. contents:: Table of Contents

Boot
----------------

Bare-metal
^^^^^^^^^^^^^^^^^

"Bare-metal"（裸机） 是一个术语，通常用于描述在嵌入式系统或计算机上运行的软件，该软件直接在硬件上运行，没有操作系统或其他软件层介入。
Bare-metal 软件是针对特定硬件平台编写的，它与硬件之间的交互是直接的，没有中间层，与之相对应的是操作系统。
Bare-metal 的一些重要特点和概念如下：

- 无操作系统：它直接管理硬件资源，包括处理器、内存、外设等，而不使用操作系统提供的抽象和服务。
- 硬件控制：Bare-metal 软件具有对硬件的细粒度控制。它可以直接操作寄存器、配置外设、设置时钟和中断等，以满足特定应用程序的需求。
- 性能和效率：由于没有操作系统的开销，Bare-metal 软件通常能够实现更高的性能和更低的延迟。这对于一些实时性要求高的应用程序非常重要。
- 嵌入式系统：Bare-metal 常用于嵌入式系统，如微控制器、嵌入式处理器等。这些系统通常需要小型、高效、快速响应的软件，因此 Bare-metal 非常适用。

Bare-metal 软件可用于各种应用，包括嵌入式控制、传感器数据采集、嵌入式网络设备、实时控制系统等。

Device Tree
^^^^^^^^^^^^^

`设备树 <https://devicetree-specification.readthedocs.io/en/stable/>`__ （Device Tree）是一种数据结构，用于描述硬件设备的组成和配置信息，特别是在嵌入式系统中。
设备树主要用于操作系统，以便在启动时了解硬件的配置和布局，从而能够正确地初始化和管理硬件设备。
在裸机环境中，CPU 通常不需要设备树。
这是因为，硬件的配置通常会直接编码到程序中，由程序直接管理，不需要设备树来描述硬件的配置。

Bootloader
^^^^^^^^^^^^^^^

引导加载程序（Bootloader）是计算机启动时运行的一段小程序。
它的主要任务是加载操作系统内核到内存，并将控制权交给内核。
当 CPU 上电启动时，CPU 会从一个固定的地址（通常是 ROM 或者固定的 RAM 地址）开始执行代码，这段代码就是引导加载程序。
引导加载程序通常只包含最基本的硬件初始化和内核加载功能。
在RISC-V处理器架构中，通常存在多个引导加载程序（Bootloader）阶段，包括零阶段引导加载程序（Zero Stage Bootloader）和一阶段引导加载程序（First Stage Bootloader）。

Zero Stage Bootloader
########################

零阶段引导加载程序通常是在处理器复位后直接运行的一小段代码。
它通常位于芯片内部的 BootROM 中，因为它需要非常快速地执行。
零阶段引导加载程序的主要任务是进行基本的硬件初始化和设置，以准备进一步的引导加载过程。
它可能会初始化内存控制器、设置栈指针、配置中断等，以便后续的引导加载程序能够正常运行。

First Stage Bootloader
######################

一阶段引导加载程序位于零阶段引导加载程序之后运行。
它通常位于可写的存储介质（如Flash存储器）中，而不是芯片内部的BootROM。
一阶段引导加载程序的主要任务是从存储介质中加载更复杂的引导加载程序，如二阶段引导加载程序（Second Stage Bootloader）或操作系统内核，到内存中并开始执行。
它可能还会进行更高级的硬件初始化，如初始化外部设备、加载驱动程序等。
这两个阶段的引导加载程序通常是为了实现引导过程的分层和模块化。
零阶段引导加载程序是最基本的初始化步骤，它保证了处理器在运行任何复杂引导加载程序之前处于一个合适的状态。
一阶段引导加载程序进一步构建在此基础上，负责加载更多的软件组件，最终启动操作系统或主应用程序。

Bootcode Generation
^^^^^^^^^^^^^^^^^^^^^^^^^

Naive Version
#####################

下面是一个名为 ``bootrom.S`` 的汇编语言文件，它包含了一个简单的 bootloader。

.. code-block::

   .section .text.start, "ax", @progbits
   .globl _start
   _start:
     li s0, 1
     slli s0, s0, 31
     csrr a0, mhartid
     la a1, _dtb
     jr s0
   
   .section .text.hang, "ax", @progbits
   .globl _hang
   _hang:
     csrr a0, mhartid
     la a1, _dtb
   1:
     wfi
     j 1b
   
   .section .rodata.dtb, "a", @progbits
   .globl _dtb
   .align 5, 0
   _dtb:
   .incbin "ariane.dtb"

接下来我们分段详细解释这个汇编代码的行为。

1. 定义 ``_start`` 标签，这是引导加载程序的入口点。

.. code-block::

   .section .text.start, "ax", @progbits
   .globl _start

- ``.section``：定义了一个新的节。
- ``.text``：这个节通常用于存储程序的代码，也就是 CPU 执行的指令。.text 节的内容在编译时就已经确定，且在程序运行时不会改变。因此，.text 节通常被设置为只读和可执行。
- ``.start``：这个节的名字。
- ``ax``：表示这个节是可分配的（a）并且可以包含代码（x）。
- ``@progbits``：表示这个节包含了程序的实际代码或数据，而不是其他一些信息，如未初始化的数据或调试信息。
- ``.globl _start``：这行代码声明了一个全局符号 _start。在链接过程中，全局符号可以被其他的对象文件引用。在大多数系统中，_start 是程序的入口点，也就是程序开始执行的地方。这通常是操作系统或引导加载程序在加载程序后首先调用的函数。

.. Hint::

   在链接器脚本或汇编语言中，“可分配”（allocatable）是一个属性，用来描述一个节（section）是否需要在程序的内存映像中分配空间。
   如果一个节被标记为“可分配”，那么在链接过程中，链接器会为这个节分配内存空间。在加载程序时，加载器会将这个节的内容加载到内存中。
   例如，包含程序代码或初始化的全局变量的节通常都是“可分配”的，因为这些代码和数据需要被加载到内存中，以便 CPU 可以执行或访问它们。
   相反，包含调试信息或符号表的节通常不是“可分配”的，因为这些信息只在链接或调试时需要，而在程序运行时并不需要加载到内存中。

.. Hint::

   内存映像（Memory Image）是一个术语，通常用来描述程序在内存中的布局和组织。
   当一个程序被加载到内存中执行时，它的代码、数据和其他资源会被放置在内存的特定位置。这些代码、数据和资源在内存中的布局就构成了这个程序的内存映像。
   内存映像通常包括以下几个部分：
   文本段（Text Segment）：包含程序的机器代码。
   数据段（Data Segment）：包含程序的全局变量和静态变量。
   堆（Heap）：用于动态内存分配，如 malloc、new 等操作。
   栈（Stack）：用于存放函数调用的局部变量和返回地址。

2. 定义 ``_start`` 函数。

.. code-block::

   _start:
     li s0, 1
     slli s0, s0, 31
     csrr a0, mhartid
     la a1, _dtb
     jr s0

``li s0, 1`` 这行代码将立即数 1 加载到寄存器 s0 中。
然后，``slli s0, s0, 31`` 这行代码将 s0 寄存器中的值左移 31 位。
这两行代码的组合效果等同于将 DRAM_BASE（0x8000_0000）加载到 s0 寄存器。

``csrr a0, mhartid`` 这行代码将 mhartid 控制和状态寄存器（CSR）的值读取到 a0 寄存器。
mhartid 寄存器包含了当前硬件线程的 ID。

``la a1, _dtb`` 这行代码将 _dtb 标签的地址加载到 a1 寄存器。
_dtb 标签通常指向设备树二进制（DTB）文件的位置，这个文件描述了硬件的配置和布局。

``jr s0`` 这行代码跳转到 s0 寄存器指向的地址。在这个例子中，这个地址应该是 DRAM_BASE，也就是系统的主内存的基地址。

3. 定义 ``_hang`` 标签以及其对应的函数。

.. code-block::

   .section .text.hang, "ax", @progbits
   .globl _hang
   _hang:
     csrr a0, mhartid
     la a1, _dtb
   1:
     wfi
     j 1b

``wfi`` 这行代码执行了等待中断（Wait For Interrupt）指令。
这个指令会使处理器进入低功耗模式，直到接收到一个中断。

``j 1b`` 这行代码跳转到前面定义的 1 标签。
1b 是一个汇编标签，1 是标签的名字，b 表示向后查找。
在这个特定的情况下，``j 1b`` 使程序进入一个无限循环，直到接收到一个中断或者复位信号。

.. Hint::

   "向后跳转"和"向前跳转"是相对于当前执行位置的。
   "向后跳转"意味着跳转到之前的代码位置，"向前跳转"意味着跳转到后面的代码位置。

_hang 代码段通常只在出现错误或特殊情况时才会执行。
例如，如果在尝试跳转到主内存执行程序时发生错误，或者在特定的硬件事件（如电源管理事件）发生时，程序可能会跳转到 _hang 代码段。

4. 定义了 _dtb 标签，即设备树二进制文件（DTB）的位置。

.. code-block::

   .section .rodata.dtb, "a", @progbits
   .globl _dtb
   .align 5, 0
   _dtb:
   .incbin "ariane.dtb"

这个节用于存储只读数据，如常量和字符串字面量。
.rodata 的 "ro" 是 "read-only" 的缩写。
.rodata 节的内容在编译时就已经确定，且在程序运行时不会改变。
但与 .text 节不同的是，.rodata 节的内容不是用来执行的代码，而是用来读取的数据。

``.align 5, 0`` 这行代码将下一行的代码对齐到 2 的 5 次方（也就是 32）字节边界。如果当前的位置不是 32 字节边界，那么会插入 0 直到达到 32 字节边界。

.. attention::

   我们流片的 bootloader 不需要设备树。

C-compatiable Version
####################

兼容 C 代码编译出来的二进制文件所需要的 bootloader 更为复杂。



   Bootloader在RISC-V CPU上运行Bare-metal软件时充当了初始化和准备阶段的角色。它负责确保硬件适当地配置和Bare-metal软件正确加载到内存中。一旦这些任务完成，Bootloader将控制权转交给Bare-metal软件，使其能够在已准备好的硬件环境中执行。
   
   二进制文件（.bin）通常是一个可执行文件，它包含了用于直接在硬件或操作系统上执行的机器代码。这些文件通常由编译器从源代码生成，然后可以直接被加载和执行。
   
   镜像文件（.img）通常是一个存储设备或文件系统的完整二进制复制。它包含了存储设备的所有内容，包括文件系统、文件、目录和元数据。镜像文件通常用于备份、恢复或在不同的设备或系统之间复制数据。在嵌入式系统开发中，镜像文件通常包含了完整的固件，包括引导加载程序、内核、应用程序和文件系统。
   
   
   
   C标准库中有一个exit函数，它会在程序执行完之后自动调用。




.. note::

   This section is under development.
